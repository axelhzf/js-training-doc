<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Backbone.js | js-training</title>
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <header>
    <div class="logo">JS<small>training</small></div>
  </header>
  <div class="content"><h1 id="backbone-js">Backbone.js</h1>
<h2 id="introducci-n">Introducción</h2>
<p>En la actualidad existen muchas librerías MVC para JavaScript: Ember.js, Angular.js, Can.js, Backbone.js, ...
Es por eso que saber elegir <a href="http://coding.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/">la librería adecuada para nuestra aplicación es muy importante</a>.</p>
<p><img src="images/mvc-battle.jpg" alt="MVC battle"></p>
<p>Backbone es una libreria Java Script que permite estructurar aplicaciones
web. Provee los componentes básicos <strong>models</strong>, <strong>collections</strong> y <strong>views</strong>
necesarios para crear aplicaciones web complejos.</p>
<p>Su creador es Jeremy Ashkenas. Trabaja en el desarrollo de noticias interactivas para el NYTimes y en DocumentCloud.
También es el creador de otras librerías como:</p>
<ul>
<li><a href="http://underscorejs.org/">Underscore.js</a></li>
<li><a href="http://coffeescript.org/">Coffeescript</a></li>
</ul>
<p>Backbone es librería bastante simple y esa es una de sus principales virtudes.</p>
<p><blockquote class="twitter-tweet" lang="en"><p>The magic of backbone, IMO is in its lack of magic. Slim, readable, non-magical source, easily extended for custom needs. <a href="https://twitter.com/search?q=%23backboneconf&amp;src=hash">#backboneconf</a></p>&mdash; Henrik Joreteg (@HenrikJoreteg) <a href="https://twitter.com/HenrikJoreteg/statuses/207850077170053120">May 30, 2012</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>Es una librería bastante popular y es utilizada por empresas importantes como Rdio, Hulu o Foursquare entre <a href="http://backbonejs.org/#examples">otros</a>.</p>
<h2 id="-por-qu-utilizar-backbone-">¿Por qué utilizar Backbone?</h2>
<p>Ya hemos visto como crear aplicaciones útilizando jQuery y mucha gente piensa que con eso es suficiente. Puede que
para aplicaciones muy simples como una landing page si sea suficiente. El problema es que cuando la
complejida aumenta necesitamos una estructura que nos permita manejarla, sino terminaremos teniendo
un código parecido a esto:</p>
<p><img src="images/spaghetti.jpeg" alt="Spaghetti code"></p>
<p>Aquí es donde Backbone es de mucha utilidad . Backbone.js añade una capa de abstracción
que permitiendo estructurar la aplicación. El principal objetivo es la separación de conceptos,
desvincular los datos del DOM para hacer la aplicación más mantenible y testeable.</p>
<p>En comparación con Angular o Ember, Backbone es la librería más simple. Provee los recursos básicos
para que apartir de ahí seamos nosotros mismos los que creemos nuestro propio framework. Es por
han aparecido muchas librerías para hacer más sencillas las tareas más repetitivas. Otra de las
ventajas es que no te fuerza a utilizar un sistema de plantillas concreto. Esto puede ser una
ventaja poco importante, pero permite integrarnos con librerías muy eficientes como
<a href="https://github.com/usepropeller/react.backbone">React.js</a> y nos va a permitir <a href="https://github.com/rendrjs/rendr">reutilizar las mismas
plantillas para el servidor y para el cliente</a>.</p>
<h2 id="estructura">Estructura</h2>
<p>Las clases básicas que provee Backbone son</p>
<ul>
<li>Models</li>
<li>Collections</li>
<li>View</li>
<li>Router</li>
</ul>
<p>La relación con el modelo MVC tradicional sería:</p>
<table>
<thead>
<tr>
<th>MVC</th>
<th>Backbone</th>
</tr>
</thead>
<tbody>
<tr>
<td>Model</td>
<td>Model / Collection</td>
</tr>
<tr>
<td>Controller</td>
<td>View / Router</td>
</tr>
<tr>
<td>View</td>
<td>Template</td>
</tr>
</tbody>
</table>
<p>La persistencía por defecto que trae Backbone es RESTFul, pero existen plugins que permite
utilizar otros mecanismos sin necesidad de modificar nuestro código. Por ejemplo:</p>
<ul>
<li><a href="https://github.com/jeromegn/Backbone.localStorage">LocalStorage</a></li>
<li><a href="https://github.com/scttnlsn/backbone.io">WebSockets</a></li>
</ul>
<h3 id="models">Models</h3>
<p>Los modelos son las clases que van a almacenar los datos de la aplicación además de gran parte
de la lógica que los rodea: converciones, validaciones, valores calculados y control de acceso.
Utilizar los modelos de Backbone nos va a proporcionar una pieza clave para manejar los cambios
en la aplicación, los <strong>Eventos</strong>.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// constructor por defecto</span>
<span class="hljs-keyword">var</span> Book = Backbone.Model.extend({});

<span class="hljs-keyword">var</span> book = <span class="hljs-keyword">new</span> Book({
    title: <span class="hljs-string">"One Thousand and One Nights"</span>,
    author: <span class="hljs-string">"Scheherazade"</span>
});

<span class="hljs-comment">// extender el constructor</span>
<span class="hljs-keyword">var</span> Book = Backbone.Model.extend({
    initialize : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attributes)</span> {</span>
        ...
    }
});

<span class="hljs-keyword">var</span> book = <span class="hljs-keyword">new</span> Book({
    title: <span class="hljs-string">"One Thousand and One Nights"</span>,
    author: <span class="hljs-string">"Scheherazade"</span>
});

book.<span class="hljs-keyword">get</span>(<span class="hljs-string">'title'</span>); <span class="hljs-comment">//"One Thousand and One Nights"</span>

book.<span class="hljs-keyword">set</span>({title: <span class="hljs-string">"March 20"</span>, content: <span class="hljs-string">"In his eyes she eclipses..."</span>});
book.<span class="hljs-keyword">set</span>(<span class="hljs-string">"title"</span>, <span class="hljs-string">"A Scandal in Bohemia"</span>);
</code></pre>
<h4 id="eventos">Eventos</h4>
<p>Los eventos nos va a permitir detectar los cambios que se producen en los modelos. Esto es
muy importante para mantener la sincronización entre los datos y las vistas.</p>
<pre><code class="lang-javascript">book.<span class="hljs-keyword">set</span>(<span class="hljs-string">'title'</span>, <span class="hljs-string">'...'</span>); <span class="hljs-comment">// Se lanza evento "change:title" y "change"</span>

book.<span class="hljs-keyword">set</span>({title : <span class="hljs-string">''</span>, content : <span class="hljs-string">''</span>}); <span class="hljs-comment">// Se lanza un evento change</span>
<span class="hljs-comment">// por cada atributo y un único "change"</span>

book.<span class="hljs-keyword">set</span>({title : <span class="hljs-string">''</span>}, {silent : <span class="hljs-keyword">true</span>}); <span class="hljs-comment">// No lanza eventos</span>
</code></pre>
<h4 id="attributes">Attributes</h4>
<p>El atributo <code>defaults</code> nos va a permitir asignar valores por defecto a otros atributos</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Meal = Backbone.Model.extend({
    defaults: {
        <span class="hljs-string">"appetizer"</span>: <span class="hljs-string">"caesar salad"</span>,
        <span class="hljs-string">"entree"</span>: <span class="hljs-string">"ravioli"</span>,
        <span class="hljs-string">"dessert"</span>: <span class="hljs-string">"cheesecake"</span>
    }
});
<span class="hljs-keyword">var</span> meal = <span class="hljs-keyword">new</span> Meal({dessert : <span class="hljs-string">'ice cream'</span>});

meal.<span class="hljs-keyword">get</span>(<span class="hljs-string">'dessert'</span>); <span class="hljs-comment">// ice cream</span>
meal.<span class="hljs-keyword">get</span>(<span class="hljs-string">'entree'</span>); <span class="hljs-comment">// ravioli</span>
</code></pre>
<p>Los atributos se almacenan internamente dentro de <code>attributes</code></p>
<p><img src="images/bb-bookObject.png" alt="Backbone internal model object"></p>
<p>No deberíamos acceder directamente a este objeto, porque estaríamos perdiendo el mecanismo
de detección de cambios. En el caso de que necesitemos acceso a todos los atributos, por ejemplo
para pasárselos a la vista para que se rendericen, podemos utilizar el método <code>toJSON</code>. Este
método devuelve una copia de los atributos.</p>
<pre><code class="lang-javascript">var artist = new <span class="hljs-filename">Backbone.Model({
    firstName</span>: <span class="hljs-string">"Wassily"</span>,
    lastName: <span class="hljs-string">"Kandinsky"</span>
});
<span class="hljs-filename">artist.set({birthday</span>: <span class="hljs-string">"December 16, 1866"</span>});

<span class="hljs-filename">artist.toJSON(); // { firstName</span>: <span class="hljs-string">"Wassily"</span>, lastName: <span class="hljs-string">"Kandinsky"</span>, birthday: <span class="hljs-string">"December 16, 1866"</span> }
</code></pre>
<p>Las validaciones se realizan en método <code>validate</code>.</p>
<pre><code class="lang-javascript">var Chapter = <span class="hljs-transposed_variable">Backbone.</span><span class="hljs-transposed_variable">Model.</span>extend({
    validate: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attrs)</span> {</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-transposed_variable">attrs.</span><span class="hljs-keyword">end</span> &lt; <span class="hljs-transposed_variable">attrs.</span>start) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"can'</span>t <span class="hljs-keyword">end</span> before it starts<span class="hljs-string">";
        }
    }
});</span>
</code></pre>
<h4 id="sincronizaci-n">Sincronización</h4>
<p>La sincronización nos va a permitir persistir los cambios que hagamos en nuestra en la aplicación.
Lo más normal en el desarrollo de aplicaciones single app es tener una API rest con la que se comunique
el cliente web. Es por eso que el mecanimos de sincronización que viene con Backbone es restful.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Book = Backbone.Model.extend({
    urlRoot : <span class="hljs-string">'/books'</span>
});

<span class="hljs-keyword">var</span> book = <span class="hljs-keyword">new</span> Book({
    title: <span class="hljs-string">"The Rough Riders"</span>,
    author: <span class="hljs-string">"Theodore Roosevelt"</span>
});

book.save(); <span class="hljs-comment">// HTTP POST /books</span>
book.<span class="hljs-keyword">set</span>(<span class="hljs-string">'title'</span>, <span class="hljs-string">'...'</span>);
book.save({author: <span class="hljs-string">"Teddy"</span>}); <span class="hljs-comment">//HTTP PUT /books/3</span>
book.fetch(); <span class="hljs-comment">// HTTP GET /books/3</span>
book.destroy(); <span class="hljs-comment">//HTTP DELETE /books/3</span>
</code></pre>
<h3 id="collections">Collections</h3>
<p>Las colecciones almacenan listas de modelos.</p>
<pre><code class="lang-javascript">
var Library = Backbone<span class="hljs-preprocessor">.Collection</span><span class="hljs-preprocessor">.extend</span>({
    model: Book
})<span class="hljs-comment">;</span>
var library = new Library([book1, book2, book3])<span class="hljs-comment">;</span>


Collection / modificar
var ship1 = Backbone<span class="hljs-preprocessor">.Model</span>({name: <span class="hljs-string">"Flying Dutchman"</span>})<span class="hljs-comment">;</span>
var ship2 = Backbone<span class="hljs-preprocessor">.Model</span>({name: <span class="hljs-string">"Black Pearl"</span>})<span class="hljs-comment">;</span>

var ships = new Backbone<span class="hljs-preprocessor">.Collection</span><span class="hljs-comment">;</span>

//trigger <span class="hljs-string">"add"</span>, <span class="hljs-string">"remove"</span> events
ships<span class="hljs-preprocessor">.add</span>([ship1, ship2])<span class="hljs-comment">;</span>
ships<span class="hljs-preprocessor">.remove</span>(ship1)<span class="hljs-comment">;</span>
ships<span class="hljs-preprocessor">.get</span>(ship2<span class="hljs-preprocessor">.id</span>)<span class="hljs-comment">;</span>
ships<span class="hljs-preprocessor">.push</span>(ship1)<span class="hljs-comment">;</span>
ships<span class="hljs-preprocessor">.pop</span>(ship1)<span class="hljs-comment">;</span>
ships<span class="hljs-preprocessor">.unshift</span>(ship1)<span class="hljs-comment">;</span>
ships<span class="hljs-preprocessor">.shift</span>(ship1)<span class="hljs-comment">;</span>
</code></pre>
<p>Además de estos métodos básico, las colleciones integran <a href="http://backbonejs.org/#Collection-Underscore-Methods">los métodos de underscore.js para
trabajar con arrays</a>.</p>
<h4 id="sincronizaci-n">Sincronización</h4>
<pre><code class="lang-javascript"><span class="hljs-built_in">var</span> Notes <span class="hljs-subst">=</span> Backbone<span class="hljs-built_in">.</span>Collection<span class="hljs-built_in">.</span>extend({
    url: <span class="hljs-string">'/notes'</span>
});

<span class="hljs-built_in">var</span> notes <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> Notes();
notes<span class="hljs-built_in">.</span>fetch(); <span class="hljs-comment">// HTTP GET /notes</span>
notes<span class="hljs-built_in">.</span>fetch({<span class="hljs-built_in">data</span>: {page: <span class="hljs-number">3</span>}})  <span class="hljs-comment">//HTTP GET /notes?page=3</span>
</code></pre>
<h3 id="router">Router</h3>
<p>El router es una parte muy importante de una aplicación. Permite almacenar el estado de una aplicación.
De forma que cuando el usuario actualice la página o copie y comparta un enlace, la web debería
ser capaz de recuperar el mismo estado.</p>
<p>Existen dos mecanismos que nos permiten modificar la url desde javascript. Por un lado tenemos
los #hashFragments por ejemplo. Esta es la opción que está soportada por todos los navegadores.
Los navegadores modernos tinene implementada una nueva API (History API) que permite modificar
la url sin necesidad de utilizar #hashFragments.</p>
<p>El router de Backbone es capaz de utilizar un mecanismo u otro dependendiendo del soporte
del navegador.</p>
<p>Básicamente lo que vamos a hacer en el router es hacer el mapeo entre patrones de url
y los métodos que se ejecutarán al acceder.</p>
<pre><code class="lang-javascript">var Router = Backbone.Router.extend({
    routes: {
        <span class="hljs-string">"help"</span>:                 <span class="hljs-string">"help"</span>,    // <span class="hljs-comment">#help</span>
        <span class="hljs-string">"search/:query"</span>:        <span class="hljs-string">"search"</span>,  // <span class="hljs-comment">#search/kiwis</span>
        <span class="hljs-string">"search/:query/p:page"</span>: <span class="hljs-string">"search"</span>   // <span class="hljs-comment">#search/kiwis/p7</span>
    },

    help: <span class="hljs-keyword">function</span>() {<span class="hljs-keyword">...</span>},
    search: <span class="hljs-keyword">function</span>(query, page) {<span class="hljs-keyword">...</span>}

});
var router = new Router();
Backbone.history.start();
Backbone.history.start({pushState : true});

router.navigate(<span class="hljs-string">"help"</span>, {trigger: true});
</code></pre>
<h3 id="view">View</h3>
<p>La vistas deberían ser la única parte de nuestra aplicación que esté en contacto con el DOM.
La vista es la encargada tanto de renderizar la vista cuando alguno de los datos se cambien
como de responder a los eventos que se produzcan en la vista por la interacción del usuario.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> DocumentView = Backbone.View.extend({
    render: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> html = <span class="hljs-keyword">this</span>.template(model.toJSON());
        <span class="hljs-keyword">this</span>.$el.html(html);
    }
});

<span class="hljs-keyword">var</span> document = <span class="hljs-keyword">new</span> Backbone.Model({title : <span class="hljs-string">'title'</span>});
<span class="hljs-keyword">var</span> documentView = <span class="hljs-keyword">new</span> DocumentView({el : <span class="hljs-string">'#document'</span>, model : document});
documentView.render();
</code></pre>
<h4 id="templates">Templates</h4>
<p>Underscore cuenta con la función <code>template</code> que es un sistema de plantillas básico.</p>
<pre><code class="lang-javascript">    <span class="hljs-keyword">var</span> DocumentView = Backbone.View.extend({
        template : _.template(<span class="hljs-string">"&lt;strong&gt;Title&lt;strong&gt; : &lt;%= title %&gt;"</span>);
        render : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">var</span> html = <span class="hljs-keyword">this</span>.template(model.toJSON());
            <span class="hljs-keyword">this</span>.$el.html(html);
        }
    });
</code></pre>
<p>El principal inconveniente de las plantillas de undescore es el código inline
necesario para hacer cosas tan sencillas como iterar por una lista de elementos.</p>
<pre><code class="lang-javascript">var list = "<span class="vbscript">&lt;% _.<span class="hljs-keyword">each</span>(people, <span class="hljs-keyword">function</span>(name) { %&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span><span class="vbscript">&lt;%= name %&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span> <span class="vbscript">&lt;% }); %&gt;</span>";
_.template(list, {people : ['moe', 'curly', 'larry']});
</code></pre>
<p>Es por eso que yo recomiendo utilizar otro sistema de plantillas. Por ejemplo uno
que está bastante extendido, además de ser el que utiliza Ember.js, es
<a href="http://handlebarsjs.com/">Handlebars</a></p>
<p><img src="images/handlebars.png" alt="Handlebars logo"></p>
<p>Este sería el mismo código que el ejemplo anterior utilizando Handlebars.</p>
<pre><code class="lang-javascript"><span class="xml">var template = Handlebars.compile(
   "</span><span class="hljs-expression">{{<span class="hljs-begin-block">#<span class="hljs-keyword">each</span> people</span>}}</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span></span><span class="hljs-expression">{{ <span class="hljs-variable">this</span> }}</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span></span><span class="hljs-expression">{{<span class="hljs-end-block">/<span class="hljs-keyword">each</span></span>}}</span><span class="xml">"
);
template({people : ['moe', 'curly', 'larry']});</span>
</code></pre>
<p>Para utilizar handlebars des nuestras vistas tenemos varias opciones:</p>
<p>Podemos compilarlas directamente en la vista.
Ya sea escribiendo la plantilla inline</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> DocumentView = Backbone.View.extend({
    template : Handlebars.compile(
        <span class="hljs-string">"&lt;strong&gt;Title&lt;strong&gt; : {{title}}"</span>);

    render : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> html = <span class="hljs-keyword">this</span>.template(model.toJSON());
        <span class="hljs-keyword">this</span>.$el.html(html);
    }
});
</code></pre>
<p>O escribiendo la plantilla en un tag script que nos
permite escribir texto multilinea.</p>
<pre><code class="lang-javascript"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/html"</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"#documentView"</span>&gt;</span><span class="javascript">
    &lt;ul&gt;
    </span></span><span class="hljs-expression">{{<span class="hljs-begin-block">#<span class="hljs-keyword">each</span> people</span>}}</span><span class="xml"><span class="javascript">
        &lt;li&gt;</span></span><span class="hljs-expression">{{ <span class="hljs-variable">name</span> }}</span><span class="xml"><span class="javascript">&lt;<span class="hljs-regexp">/li&gt;
    </span></span></span><span class="hljs-expression">{{<span class="hljs-end-block">/<span class="hljs-keyword">each</span></span>}}</span><span class="xml"><span class="javascript">
    &lt;<span class="hljs-regexp">/ul&gt;
</span></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">var</span> DocumentView = Backbone.View.extend({
    template : Handlebars.compile($(<span class="hljs-string">'#documentView'</span>).html()),
    render : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">this</span>.$el.html(<span class="hljs-keyword">this</span>.template(<span class="hljs-keyword">this</span>.collection.toJSON()));
    }
});
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></span>
</code></pre>
<p>Pero la opción más recomendada es precompilar las plantillas. Por ejemplo
tenemos este plugin <a href="https://github.com/lazd/gulp-handlebars">gulp-handlebars</a> que nos permite
hacerlo.</p>
<h4 id="events">Events</h4>
<p>El atributo <code>events</code> nos permite asociar los eventos de DOM que se producen en las vistas
con métodos que se van a ejecutar cuando se produzcan.</p>
<pre><code class="lang-javascript">var DocumentRow = Backbone.View.extend({

    events: {
        <span class="hljs-string">"click .icon"</span>:          <span class="hljs-string">"open"</span>,
        <span class="hljs-string">"click .button.edit"</span>:   <span class="hljs-string">"openEditDialog"</span>,
        <span class="hljs-string">"click .button.delete"</span>: <span class="hljs-string">"destroy"</span>
    },

    render: <span class="hljs-keyword">function</span>() {<span class="hljs-keyword">...</span>},
    open: <span class="hljs-keyword">function</span>() {<span class="hljs-keyword">...</span>},
    openEditDialog : <span class="hljs-keyword">function</span>() {<span class="hljs-keyword">...</span>},

});
</code></pre>
<p>La vista es la encarga de responder tanto a los eventos del DOM como a los eventos que se produzcan
en los modelos y para los que sea necesario actualizar las vistas.</p>
<pre><code class="lang-javascript">model<span class="hljs-preprocessor">.on</span>(<span class="hljs-string">"change"</span>, view<span class="hljs-preprocessor">.render</span>)<span class="hljs-comment">;</span>
view<span class="hljs-preprocessor">.on</span>(<span class="hljs-string">"addUser"</span>, function (user) {
    this<span class="hljs-preprocessor">.collection</span><span class="hljs-preprocessor">.add</span>(user)
})<span class="hljs-comment">;</span>
</code></pre>
<h2 id="testing">Testing</h2>
<p>Aquí tienen un artículo muy bueno que explica como testear cada uno de los componentes
de Backbone.</p>
<p><a href="http://tinnedfruit.com/2011/03/03/testing-backbone-apps-with-jasmine-sinon.html">http://tinnedfruit.com/2011/03/03/testing-backbone-apps-with-jasmine-sinon.html</a></p>
<p>El caso que puede ser más complejo de probar es testear la vistas. La forma más sencillas
sería comprobar que el HTML generador al renderizar la vista sea el correcto.</p>
<pre><code class="lang-javascript">describe(<span class="hljs-string">"TodoView"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    beforeEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">this</span>.model = <span class="hljs-keyword">new</span> Backbone.Model({title: <span class="hljs-string">"My Todo"</span>, id: <span class="hljs-number">1</span>});
        <span class="hljs-keyword">this</span>.view = <span class="hljs-keyword">new</span> TodoView({model:<span class="hljs-keyword">this</span>.model});
    });
    it(<span class="hljs-string">"produces the correct HTML"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">this</span>.view.render();
        expect(<span class="hljs-keyword">this</span>.view.el.innerHTML)
            .toEqual(<span class="hljs-string">'&lt;a href="#todo/1"&gt;&lt;h2&gt;My Todo&lt;/h2&gt;&lt;/a&gt;'</span>);
    });
});
</code></pre>
<h2 id="aplicaci-n">Aplicación</h2>
<p>Como ejercicios vamos a crear una aplicación de chat utilizando Backbone. Esta aplicación cliente se conectará a un servidor que nos permitirá realizar comunicación en tiempo real.</p>
<p>Un consejo cuando empiezas a desarrollar una aplicación es analizar los modelos que tendrá la aplicación. Esto nos va ayudar tanto a planificar el código del front como a planificar el código de backend.</p>
<p>Los modelos que vamos a definir son un modelo User que va a mantener la información de los usuarios que estan conectados y otro modelo Message que representará cada uno de los mensaje que se manden.</p>
<p>Una vez tenemos definido nuestro modelo de datos, podemos empezar a hacer un mockup de nuestra aplicación que noes permita identificar las partes de la que está compuesta.</p>
<p><img src="images/bb-chatViews.png" alt="Chat views"></p>
<p>Una manera de separar las distintas vistas de la aplicación va a ser en termino de las necesidades de renderizado. En nuestro caso tendremos una vista que lista los usuarios, que se va a renderizar cada vez que un usuario se conecte o se desconecte. Tendremos otra vista para mostrar los mensajes que se va a renderizar cada vez que se añada un mensaje nuevo. Por último la vista InputView se actualizará con la interacción del usuario.</p>
<p>Un diagram interesante que podemos realizar es un diagrama de eventos que represente los eventos que van a conectar los modelos y las vistas.</p>
<p><img src="images/bb-eventsDiagram.png" alt="Events diagram"></p>
<p>La primera vista que vamos a definir es la vista de los usuarios. Esta vista es bastante sencilla y se limita únicamente a renderizar la collections de usuarios.</p>
<pre><code class="lang-javascript">App.UsersView = Backbone.View.extend({

    template : Handlebars.compile($(<span class="hljs-string">'#usersTmpl'</span>).html()),

    render : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> context = {
            users : <span class="hljs-keyword">this</span>.collection.toJSON()
        };
        <span class="hljs-keyword">this</span>.$el.html(<span class="hljs-keyword">this</span>.template(context));
    }
});
</code></pre>
<p>Para probar que el código funciona correctamente prueba este código desde la consola o añadelo en el código de la aplicación (recuerda borrarlo después)</p>
<pre><code class="lang-javascript"><span class="hljs-filename">App.users.reset([{name </span>: <span class="hljs-string">'user1'</span>}, {<span class="hljs-built_in">name : <span class="hljs-string">'user2'</span>}]);
App.usersView.render();</span>
</code></pre>
<p>Ahora debemos conectar los eventos para mantener la sincronización entre la vista y el modelo.</p>
<pre><code class="lang-javascript">App.users.on(<span class="hljs-string">'add reset'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    App.usersView.render();
});
App.users.reset([{name : <span class="hljs-string">'user1'</span>}, {name : <span class="hljs-string">'user2'</span>}]);
</code></pre>
<p>En otros casos en los que estemos trabajando con collecciones y vistas, suele ser necesario conectar el evento &quot;remove&quot;. En nuestro caso no va a ser necesario porque el usuario nos va a devolver siempre la lista completa de usuarios. El único evento que se va a lanzar es el reset.</p>
<p>Para la vista de los mensajes vamos a utilizar otra forma de hacer las cosas. En lugar de renderizar el listado completo, nuestra plantilla va a representar un único mensaje.</p>
<pre><code class="lang-javascript">App.MessagesView = Backbone.View.extend({
    msgTemplate : Handlebars.compile($(<span class="hljs-string">'#msgTmpl'</span>).html()),
    render : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> view = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">this</span>.collection.each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(message)</span> {</span>
            view.appendMsg(message);
        });
    },
    appendMsg : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(msg)</span> {</span>
        <span class="hljs-keyword">var</span> context = msg.toJSON();
        <span class="hljs-keyword">this</span>.$el.append(<span class="hljs-keyword">this</span>.msgTemplate(context));
    }
});
</code></pre>
<p>El servidor nos notificará cada vez que se añada un mensaje nuevo, por lo tanto esta implementación nos será más útil porque no tendremos que renderizar la lista completa de nuevo.</p>
<p>Prueba la vista añadiendo algunos mensajes.</p>
<pre><code class="lang-javascript"><span class="hljs-filename">App.messages.reset([
    {username </span>: <span class="hljs-string">'username'</span>, timestamp: <span class="hljs-string">'01-01-2012'</span>, msg : <span class="hljs-string">'hola'</span>},
    {<span class="hljs-built_in">username : <span class="hljs-string">'username2'</span>, timestamp: <span class="hljs-string">'01-01-2012'</span>, msg : <span class="hljs-string">'mundo'</span></span>}
]);
<span class="hljs-filename">App.messagesView.render();</span>
</code></pre>
<p>Conectamos los eventos de la nueva vista</p>
<pre><code class="lang-javascript">App.messages.on(<span class="hljs-string">'add'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(message)</span> {</span>
    App.messagesView.appendMsg(message);
});
App.messages.on(<span class="hljs-string">'reset'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    App.messagesView.render();
});
<span class="hljs-keyword">var</span> msg1 = <span class="hljs-keyword">new</span> App.Message(
  {username : <span class="hljs-string">'username'</span>, timestamp: <span class="hljs-string">'01-01-2012'</span>, msg : <span class="hljs-string">'hola'</span>});
<span class="hljs-keyword">var</span> msg2 = <span class="hljs-keyword">new</span> App.Message(
  {username : <span class="hljs-string">'username2'</span>, timestamp: <span class="hljs-string">'01-01-2012'</span>, msg : <span class="hljs-string">'mundo'</span>});
App.messages.reset([msg1]);
App.messages.add(msg2);
</code></pre>
<p>En este caso tenemos dos eventos distintos porque se llamará a &quot;reset&quot; cuando se conecte al servidor y a &quot;add&quot; cuando llegue un mensaje nuevo</p>
<h2 id="ejercicios">Ejercicios</h2>
<ul>
<li>Cuando se añade un mensaje nuevo has que la vista haga scroll.</li>
<li>Diferencia entre los mensaje del propios y los del resto de usuario.</li>
<li>Sustitución de smiles</li>
</ul>
<h2 id="pistas">Pistas</h2>
<ul>
<li><code>$el.scrollTop()</code> permite mover el scroll</li>
<li><code>$el.prop(&#39;scrollHeight&#39;)</code> permite conocer el tamaño actual del scroll</li>
<li>En el css están preparadas las clases &quot;chat-bubble me&quot; y &quot;chat-bubble other&quot;</li>
<li>Hay generado un sprite con smiles, algunos códigos son:</li>
</ul>
<pre><code><span class="hljs-keyword">var</span> smiles = [<span class="hljs-string">":)"</span>, <span class="hljs-string">":'("</span>, <span class="hljs-string">":P"</span>, <span class="hljs-string">";)"</span>, <span class="hljs-string">":*"</span>, <span class="hljs-string">":D"</span>, <span class="hljs-string">":@"</span>, <span class="hljs-string">"¬¬"</span>, <span class="hljs-string">"8|"</span>];
<span class="hljs-keyword">var</span> codes  = [<span class="hljs-string">"85"</span>, <span class="hljs-string">"358"</span>, <span class="hljs-string">"348"</span>, <span class="hljs-string">"344"</span>, <span class="hljs-string">"363"</span>, <span class="hljs-string">"86"</span>, <span class="hljs-string">"361"</span>, <span class="hljs-string">"353"</span>, <span class="hljs-string">"352"</span>];
</code></pre><h2 id="soluci-n">Solución</h2>
<p>Hacer scroll cuando se añade un mensaje nuevo</p>
<pre><code class="lang-javascript">scrollBottom : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.$el.scrollTop(<span class="hljs-keyword">this</span>.$el.prop(<span class="hljs-string">'scrollHeight'</span>));
},

appendMsg : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(msg)</span> {</span>
    <span class="hljs-keyword">var</span> context = msg.toJSON();
    <span class="hljs-keyword">this</span>.$el.append(<span class="hljs-keyword">this</span>.msgTemplate(context));
    <span class="hljs-keyword">this</span>.scrollBottom();
}
</code></pre>
<p>Modificar el color de las burbujas según el usuario</p>
<pre><code class="lang-javascript">initialize : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options)</span> {</span>
    <span class="hljs-keyword">this</span>.config = options.config;
},
appendMsg : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(msg)</span> {</span>
    <span class="hljs-keyword">var</span> context = msg.toJSON();
    context.color = context.username === <span class="hljs-keyword">this</span>.config.<span class="hljs-keyword">get</span>(<span class="hljs-string">'username'</span>) ? <span class="hljs-string">"me"</span> : <span class="hljs-string">"other"</span>;
    <span class="hljs-keyword">this</span>.$el.append(<span class="hljs-keyword">this</span>.msgTemplate(context));
    <span class="hljs-keyword">this</span>.scrollBottom();
}
</code></pre>
<pre><code class="lang-javascript"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/html"</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"msgTmpl"</span>&gt;</span><span class="javascript">
        &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"chat-bubble </span></span></span><span class="hljs-expression">{{<span class="hljs-variable">color</span>}}</span><span class="xml"><span class="javascript"><span class="hljs-string">"&gt;</span></span></span>
</code></pre>
<p>Sustitución de smiles</p>
<pre><code class="lang-javascript">getHtmlMsg : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(msg)</span> {</span>
    <span class="hljs-keyword">var</span> smiles = [<span class="hljs-string">":)"</span>, <span class="hljs-string">":'("</span>, <span class="hljs-string">":P"</span>, <span class="hljs-string">";)"</span>, <span class="hljs-string">":*"</span>, <span class="hljs-string">":D"</span>, <span class="hljs-string">":@"</span>, <span class="hljs-string">"¬¬"</span>, <span class="hljs-string">"8|"</span>],
    codes  = [<span class="hljs-string">"85"</span>, <span class="hljs-string">"358"</span>, <span class="hljs-string">"348"</span>, <span class="hljs-string">"344"</span>, <span class="hljs-string">"363"</span>, <span class="hljs-string">"86"</span>, <span class="hljs-string">"361"</span>, <span class="hljs-string">"353"</span>, <span class="hljs-string">"352"</span>];

    <span class="hljs-keyword">var</span> result = msg;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; smiles.length; i++){
        <span class="hljs-keyword">var</span> smile = smiles[i], code = codes[i];
        result = result.replace(smile, <span class="hljs-string">'&lt;i class="icon-'</span> + code + <span class="hljs-string">'"&gt;&lt;/i&gt;'</span>);
    }
    <span class="hljs-keyword">return</span> result;
},

appendMsg : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(msg)</span> {</span>
    <span class="hljs-keyword">var</span> context = msg.toJSON();
    context.htmlMsg = <span class="hljs-keyword">this</span>.getHtmlMsg(context.msg);
...
</code></pre>
<p>En Handlebars la triple llave {{{ }}} no escapa las variables.</p>
<pre><code class="lang-javascript"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>{{{ htmlMsg }}}<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
</code></pre>
<h3 id="inputview">InputView</h3>
<p>Esta vista va a gestionar la interacción del usuario</p>
<pre><code class="lang-javascript">App.InputView = Backbone.View.extend({

    initialize : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options)</span> {</span>
        <span class="hljs-keyword">this</span>.$input = <span class="hljs-keyword">this</span>.$el.find(<span class="hljs-string">'input'</span>);
    },

    events : {
        <span class="hljs-string">"keypress"</span> : <span class="hljs-string">"keypress"</span>
    },

    keypress : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
        <span class="hljs-keyword">if</span> (e.which == <span class="hljs-number">13</span>) { <span class="hljs-comment">// enter</span>
            <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.$input.val();
            <span class="hljs-keyword">this</span>.$input.val(<span class="hljs-string">''</span>);

            <span class="hljs-keyword">var</span> msg = <span class="hljs-keyword">new</span> App.Message({msg : val});
            <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">"newMessage"</span>, msg);
        }
    }
});
</code></pre>
<p>Conectamos los eventos</p>
<pre><code class="lang-javascript">App<span class="hljs-preprocessor">.inputView</span><span class="hljs-preprocessor">.on</span>(<span class="hljs-string">"newMessage"</span>, function (msg) {
    App<span class="hljs-preprocessor">.messages</span><span class="hljs-preprocessor">.add</span>(msg)<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>Podríamos definir algún tipo de validación, como que los mensajes no deberían estar vacios.</p>
<pre><code class="lang-javascript">App<span class="hljs-preprocessor">.Message</span> = Backbone<span class="hljs-preprocessor">.Model</span><span class="hljs-preprocessor">.extend</span>({
    validate : function (attributes) {
        if(_<span class="hljs-preprocessor">.isUndefined</span>(attributes<span class="hljs-preprocessor">.msg</span>) || attributes<span class="hljs-preprocessor">.msg</span><span class="hljs-preprocessor">.length</span> === <span class="hljs-number">0</span>) {
            return <span class="hljs-string">"el mensaje debe tener contenido"</span><span class="hljs-comment">;</span>
        }
    }
})<span class="hljs-comment">;</span>
</code></pre>
<p>Únicamente en el caso de que el mensaje sea valido, sera cuando lancemos el evento.</p>
<pre><code class="lang-javascript">keypress : function (e) {
    <span class="hljs-keyword">if</span> (e.which == <span class="hljs-number">13</span>) { <span class="hljs-comment">// enter</span>
        <span class="hljs-keyword">var</span> <span class="hljs-keyword">val</span> = <span class="hljs-keyword">this</span>.$input.<span class="hljs-keyword">val</span>();

        <span class="hljs-keyword">var</span> msg = <span class="hljs-keyword">new</span> App.Message({msg : <span class="hljs-keyword">val</span>});
        <span class="hljs-keyword">if</span>(msg.isValid()){
            <span class="hljs-keyword">this</span>.$input.<span class="hljs-keyword">val</span>(<span class="hljs-string">''</span>);
            <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">"newMessage"</span>, msg);
        }
    }
}
</code></pre>
<h2 id="servidor">Servidor</h2>
<p>El código del backend utiliza Node.js y socket.io. Todavía no hemos entrado en detalle con Node.js pero lo haremos más adelante. Por ahora podemos echarle un vistazo al código.</p>
<p><a href="https://github.com/axelhzf/chat/blob/master/server/app.js">https://github.com/axelhzf/chat/blob/master/server/app.js</a></p>
<h2 id="sincronizaci-n-de-cliente-y-servidor">Sincronización de cliente y servidor</h2>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> socket = io.connect(<span class="hljs-string">'http://chat-tlp2k12.herokuapp.com'</span>);
socket.on(<span class="hljs-string">'connect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> username = prompt(<span class="hljs-string">"What's your name?"</span>);
    App.config.<span class="hljs-keyword">set</span>(<span class="hljs-string">'username'</span>, username);
    socket.emit(<span class="hljs-string">'adduser'</span>, username);
});
socket.on(<span class="hljs-string">"initchat"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> {</span>
    App.messages.reset(response);
});
socket.on(<span class="hljs-string">'updatechat'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(message)</span> {</span>
    App.messages.add(message);
});
socket.on(<span class="hljs-string">'updateusers'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
    <span class="hljs-keyword">var</span> users = _.map(_.keys(data), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
        <span class="hljs-keyword">return</span> {name : name};
    });
    App.users.reset(users);
});
App.inputView.on(<span class="hljs-string">"newMessage"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(message)</span> {</span>
    socket.emit(<span class="hljs-string">'sendchat'</span>, message.<span class="hljs-keyword">get</span>(<span class="hljs-string">'msg'</span>));
});
</code></pre>
<p>Al intentar conectarte a un servidor externo el navegador te bloqueará por seguridad. Lo que podemos hacer en estos casos para probar la aplicación es deshabilitar esa medida de seguridad.</p>
<pre><code>OS X : `<span class="hljs-built_in">open</span> -<span class="hljs-operator">a</span> /Applications/Google\ Chrome.app <span class="hljs-comment">--args --disable-web-security`</span>
Windows : `chrome.exe <span class="hljs-comment">--disable-web-security`</span>
</code></pre><h1 id="recursos">Recursos</h1>
<ul>
<li><a href="http://addyosmani.github.io/backbone-fundamentals/">Developing Backbone.js Applications</a></li>
<li><a href="http://ricostacruz.com/backbone-patterns/">Backbone Patterns</a></li>
<li><a href="http://lostechies.com/derickbailey/">Derick Bailey</a></li>
</ul>

  </div>
  <footer><a href="http://twitter.com/axelhzf" about="_blank">Twitter</a><a href="http://github.com/axelhzf" about="_blank">Github</a></footer>
</body>