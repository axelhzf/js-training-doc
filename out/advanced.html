<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Avanzado | js-training</title>
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <header>
    <div class="logo">JS<small>training</small></div>
  </header>
  <div class="content"><p>Uno de los libros básico que debería leer toda persona que está aprendiendo JavaScript es <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">&quot;JavaScript: The Good Parts&quot;</a> de <a href="http://en.wikipedia.org/wiki/Douglas_Crockford">Douglas Crockford</a>. En el libro comenta que todos los lenguajes tienen buenas ideas y malas ideas, fallos de diseño que pueden hacer que el programador cometa fallos en sus programas. Es importante conocer las buenas practicas para emplearlas y así evitar posibles problemas. Mucha gente hace incapié en las malas ideas de JavaScript, considerándolo un lenguaje de juguete que no está a la altura de otros, pero no se dan cuentas de que las buenas ideas lo hacen superior a otros lenguajes en muchos aspectos.</p>
<p>Buenas ideas:</p>
<ul>
<li>Funciones de primer orden</li>
<li>Tipado dinámico</li>
<li>Objetos dinámicos</li>
<li>Herencia por prototype</li>
</ul>
<p>Malas ideas:</p>
<ul>
<li>Variables globales</li>
<li>==</li>
</ul>
<h2 id="-vs-">== vs ===</h2>
<p>La principal diferencia entre el operador <code>==</code> y <code>===</code> es que el primero realiza conversión de tipos</p>
<pre><code class="lang-js"><span class="hljs-setting">1 =<span class="hljs-value">= <span class="hljs-number">1</span>     // <span class="hljs-keyword">true</span></span></span>
<span class="hljs-setting">1 =<span class="hljs-value">== <span class="hljs-number">1</span>    // <span class="hljs-keyword">true</span></span></span>
<span class="hljs-setting">1 =<span class="hljs-value">= '<span class="hljs-number">1</span>'   // <span class="hljs-keyword">true</span></span></span>
<span class="hljs-setting">1 =<span class="hljs-value">== '<span class="hljs-number">1</span>'  // <span class="hljs-keyword">false</span></span></span>
</code></pre>
<h2 id="scope">Scope</h2>
<p>Por defecto, el scope de las variables es global. Se definen en un objeto global, en que en el caso del navegador se llama <code>window</code>.</p>
<pre><code class="lang-js">a = <span class="hljs-number">20</span>;
console.<span class="hljs-keyword">log</span>(a); <span class="hljs-comment">//20</span>
console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">window</span>.a); <span class="hljs-comment">// 20</span>
</code></pre>
<p>Si utilizamos <code>var</code> la variable se define en el ámbito de la función donde está contenido.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">'global'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printLocal</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> a = <span class="hljs-string">'local'</span>;
    console.log(a);
}

console.log(a); <span class="hljs-comment">//global</span>
printLocal(); <span class="hljs-comment">//local</span>
</code></pre>
<p>A diferencia de otros lenguajes de programación como Java, los bloques no definen un scope.</p>
<pre><code class="lang-js">function <span class="hljs-function"><span class="hljs-keyword">fn</span>(</span>) {
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">true</span>) {
        var a = <span class="hljs-number">10</span>;
    }
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) {
        var b = i;
    }
    console.<span class="hljs-keyword">log</span>(a);
    console.<span class="hljs-keyword">log</span>(b);
}
<span class="hljs-function"><span class="hljs-keyword">fn</span>(</span>);
<span class="hljs-comment">// 10</span>
<span class="hljs-comment">// 19</span>
</code></pre>
<p>Es por esto que existen personas que prefieren definir todas las variables al inicio de la función, para evitar este tipo de problemas. Yo personalmente no suelo utilizar esta practica.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span> {</span>
    var a, b;
    <span class="hljs-keyword">if</span>(true) <span class="hljs-cell">{
        a = <span class="hljs-number">10</span>;
    }</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-number">20</span>; <span class="hljs-built_in">i</span>++) <span class="hljs-cell">{
        b = i;
    }</span>
    <span class="hljs-transposed_variable">console.</span><span class="hljs-built_in">log</span>(a);
    <span class="hljs-transposed_variable">console.</span><span class="hljs-built_in">log</span>(b);
}
</code></pre>
<p>Siempre debemos definir las variables utilizar <code>var</code> para evitar efectos colaterales al modificar variables global sin darnos cuenta</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">'global'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printLocal</span> <span class="hljs-params">()</span> {</span>
    a = <span class="hljs-string">'local'</span>;
    console.log(a);
}

console.log(a); <span class="hljs-comment">//global</span>
printLocal(); <span class="hljs-comment">//local</span>
console.log(a); <span class="hljs-comment">//local</span>
</code></pre>
<p>Para evitar la utilización de variables globales se suelen utilizar las &#39;self-invoking functions&#39;. La forma de definirlas es</p>
<pre><code class="lang-js"><span class="hljs-list">(<span class="hljs-title">function</span> <span class="hljs-list">()</span> {
    var a = 'this is not global'<span class="hljs-comment">;</span>
    console.log<span class="hljs-list">(<span class="hljs-title">a</span>)</span><span class="hljs-comment">;</span>
})</span><span class="hljs-list">()</span><span class="hljs-comment">;</span>
</code></pre>
<p>Definiendo una función que se llama a si misma estamos consiguiendo definir un ámbito para que la variable a no esté definida en el scope global.</p>
<p>Es posible que cuando veas código de alguna librerías veas a que las &#39;self-invoking functions&#39; le pasan parámetros, por ejemplo:</p>
<pre><code class="lang-js"><span class="hljs-list">(<span class="hljs-title">function</span><span class="hljs-list">( window, $, undefined )</span> {
    // code
})</span><span class="hljs-list">(<span class="hljs-title">window</span>, jQuery)</span><span class="hljs-comment">;</span>
</code></pre>
<p>Utilizando parámetros conseguimos varios efectos. El primero es que hemos establecido una especie de contrato donde especificamos las funciones del ámbito global que vamos a utilizar, en este caso <code>window</code> y <code>jQuery</code>. También indirectamente podemos crear alias para estas variables, por ejemplo la variable que en el ámbito global se llama <code>jQuery</code>, dentro de nuestra función la utilizaremos como <code>$</code>. El último de los parámetros personalmente no lo suelo utilizar, me parece demasiado paranoico. Consiste en que alguien puede haber sobrescrito el valor de la variable <code>undefined</code> por otro. Al no pasar un tercer parámetro cuando invocamos la función nos aseguramos de que la variable <code>undefined</code> tiene el valor <code>undefined</code>. Personalmente nunca me he topado con un caso en el que esto sea realmente necesario.</p>
<h2 id="funciones-con-n-mero-de-par-metros-variables">Funciones con número de parámetros variables</h2>
<p>Todas las función definen dos parámetros por defecto: <code>this</code> y <code>arguments</code>. <code>arguments</code> contiene todos los parámetros que se han especificado al invocar una función, permitiendo implementar funciones con número de parámetros variables.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multipleArgs</span> <span class="hljs-params">()</span> {</span>
    console.log(<span class="hljs-built_in">arguments</span>);
}

multipleArgs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
multipleArgs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);
</code></pre>
<p>Debido a un fallo de diseño, <code>arguments</code> es una variable de tipo array, pero no es realmente un array. Tiene una property length y se pueden acceder a los elementos con [], pero no tiene todos los métodos de un array.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multipleArgs</span> <span class="hljs-params">()</span> {</span>
    console.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);
    console.log(<span class="hljs-built_in">arguments</span>.length);
    console.log(<span class="hljs-built_in">arguments</span>.slice); <span class="hljs-comment">//undefined</span>
}

multipleArgs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
multipleArgs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);
</code></pre>
<p>Si queremos convertir la variable <code>arguments</code> a un array podemos utilizar</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
</code></pre>
<h2 id="first-class-function">First-class function</h2>
<p>JavaScript soporta pasar como parámetros y devolver funciones.</p>
<p>Este es el modo imperativo de imprimir los elementos de un array.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printElements</span> <span class="hljs-params">(array)</span> {</span>
    <span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-transposed_variable">array.</span><span class="hljs-built_in">length</span> ; <span class="hljs-built_in">i</span>++) <span class="hljs-cell">{
        console.log(array[i]);
    }</span>
}
printElements(<span class="hljs-matrix">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span>);
</code></pre>
<p>Si hicieramos una implementación funcional</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span> <span class="hljs-params">(array, fn)</span> {</span>
    <span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-transposed_variable">array.</span><span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++) <span class="hljs-cell">{
        fn(array[i]);
    }</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span><span class="hljs-params">(element)</span> {</span>
    <span class="hljs-transposed_variable">console.</span><span class="hljs-built_in">log</span>(element);
}

forEach(<span class="hljs-matrix">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span>, print);
</code></pre>
<p>En la implementación funcional estamos abstrayendo el recorrer un array en la función <code>forEach</code>, que recibe como segundo parámetro una función que es la que llamará en cada una de las iteraciones. Entraremos más en detalle en programación funcional cuando veamos la librería Underscore.</p>
<p>Las funciones como parámetros son clave en la programación asíncrona. Es muy común que las funciones que realizan tareas asíncronas reciban como parámetro una función que se invocará cuando haya terminado la tarea asíncrona. A este tipo de parámetro se le llama callbacks.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delayedAlert</span><span class="hljs-params">(callback)</span> {</span>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        alert(<span class="hljs-string">'hello'</span>);
        callback();
    }, <span class="hljs-number">2000</span>);
    console.log(<span class="hljs-string">'finish delayed alert'</span>);
}

delayedAlert(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    console.log(<span class="hljs-string">'callback!'</span>);
});

<span class="hljs-comment">// finish delayed alert</span>
<span class="hljs-comment">// Alert</span>
<span class="hljs-comment">// callback!</span>
</code></pre>
<p>Las funciones pueden devolver funciones</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        console.log(count++);
    }
}
<span class="hljs-keyword">var</span> count = counter();
count();
count();
count();
</code></pre>
<h2 id="closure">Closure</h2>
<p>Las funciones pueden acceder a todas las variables de la función donde fueron definidas (excepto this y arguments).</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">"js-training"</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFn</span><span class="hljs-params">()</span> {</span>
      console.log(name);
  }
  innerFn();
}
fn();
</code></pre>
<p>Un caso más interesante es cuando la inner function tiene un ciclo de vida mayor que la función que la englobal</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        console.log(count++);
    }
}
<span class="hljs-keyword">var</span> count = counter();
count();
count();
count();
</code></pre>
<p>Este es un mecanismo que permite definir variables privadas, como la variable <code>count</code>.</p>
<p>Esta <a href="http://daniellmb.github.io/JavaScript-Scope-Context-Coloring/example/scope-coloring.html">herramienta</a> hace un resaltado de sintaxis del código en función del scope.</p>
<h2 id="what-it-is-this-">What it is &quot;this&quot;?</h2>
<p>El parámetro <code>this</code> es muy importante en programación orientada a objetos y su valor está determinado por el patrón de invocación utilizado.
Existen cuatro patrones de invocación distintos en javascript: Method invocation pattern, function invocation pattern, constructor invocation pattern y apply invocation pattern.</p>
<h5 id="method-invocation-pattern">Method invocation pattern</h5>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> myObject = {
    increment : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>

    }
}
myObject.increment();
<span class="hljs-comment">// this == myObject</span>
</code></pre>
<h5 id="function-invocation-pattern">Function Invocation Pattern</h5>
<pre><code class="lang-js"><span class="hljs-reserved">function</span> add(a, b) {
    <span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-reserved">var</span> sum = add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-regexp">//</span> <span class="hljs-keyword">this</span> == <span class="hljs-built_in">global</span> object<span class="hljs-function"> -&gt;</span> <span class="hljs-built_in">window</span>
</code></pre>
<h5 id="constructor-invocation-pattern">Constructor Invocation Pattern</h5>
<p>Javascript es un lenguaje con herencia de prototype, esto quiere decir que un objeto puede heredar properties directamente de otro objeto.
Cuando una función se invoca utilizando el prefijo new, se crea un nuevo objeto y el valor de this apuntará a ese nuevo objeto.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> Quo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(string)</span> {</span>
    <span class="hljs-keyword">this</span>.status = string;
};
Quo.prototype.get_status = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(  )</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.status;
};
<span class="hljs-keyword">var</span> myQuo = <span class="hljs-keyword">new</span> Quo(<span class="hljs-string">"confused"</span>);
</code></pre>
<h5 id="apply-invocation-pattern">Apply Invocation Pattern</h5>
<p>Los métodos <code>apply</code> y <code>call</code> permite invocar una función especificandole el valor que debe tener el this. La diferencia entre las dos funciones que la primera recibe un array con los parámetros mientras que la segunda recibe un número de parámetros variables.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> parameters = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);

<span class="hljs-keyword">var</span> thisObject = <span class="hljs-comment">{}</span>;

<span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">add</span>.apply(thisObject, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);
<span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">add</span>.call(thisObject, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
</code></pre>
<h2 id="problemas-con-this">Problemas con this</h2>
<p>El principal problema con this, es no saber qué valor tiene en cada momento.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        console.log(count++);
    }
}
<span class="hljs-keyword">var</span> count = counter();
count();
count();
</code></pre>
<p>Supongamos que queremos almacenar la variable <code>count</code> en this.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> counter = {
    create : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            console.log(<span class="hljs-keyword">this</span>.count++);
        }
    }
}
<span class="hljs-keyword">var</span> count = counter.create();
count();
count();
</code></pre>
<p>Este código no va a funcionar. ¿Cual es el problema? El valor del this no es el mismo en las dos funciones.
Si quisieramos hacer esto, podríamos definir una variable local que almacenara el valor del this.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> counter = {
    create : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            console.log(self.count++);
        }
    }
}
<span class="hljs-keyword">var</span> count = counter.create();
count();
count();
</code></pre>
<h1 id="ejercicios">Ejercicios</h1>
<h4 id="map">Map</h4>
<p>La función map permite manipular los elementos de un array. Se parece a la función <code>forEach</code> que vimos anteriormente, pero <code>map</code> almacena el valor de la evaluación de todas las funciones mientras itera.</p>
<pre><code class="lang-js">it(<span class="hljs-string">"map"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> multiplyByTwo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a)</span> {</span>
        <span class="hljs-keyword">return</span> a * <span class="hljs-number">2</span>;
    };
    expect(map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], multiplyByTwo)).to.deep.equal([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]);
});
</code></pre>
<h4 id="curry">Curry</h4>
<p>La función curry permite hacer una aplicación parcial de los elementos de una función.</p>
<pre><code class="lang-js">it(<span class="hljs-string">"curry"</span>, function () {
    function <span class="hljs-keyword">add</span> (<span class="hljs-built_in">x</span>, <span class="hljs-built_in">y</span>) {
        return <span class="hljs-built_in">x</span> + <span class="hljs-built_in">y</span><span class="hljs-comment">;</span>
    }
    var <span class="hljs-keyword">inc</span> = curry(<span class="hljs-keyword">add</span>, <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
    expect(<span class="hljs-keyword">inc</span>(<span class="hljs-number">10</span>))<span class="hljs-preprocessor">.to</span><span class="hljs-preprocessor">.equal</span>(<span class="hljs-number">11</span>)<span class="hljs-comment">;</span>
    expect(<span class="hljs-keyword">inc</span>(<span class="hljs-number">23</span>))<span class="hljs-preprocessor">.to</span><span class="hljs-preprocessor">.equal</span>(<span class="hljs-number">24</span>)<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<h4 id="memoize">Memoize</h4>
<p>La función memoize permite crear una cache de las ejecuciones de una función. Cuando se invoca una función se almacena el resultado en una cache. Si la función se vuelve a llamar con los mismos parámetros, el resultado se obtiene de la cache en lugar de evaluar de nuevo la función.</p>
<pre><code class="lang-js">it(<span class="hljs-string">"Memoize"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> multiplyByTwo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a)</span> {</span>
        <span class="hljs-keyword">return</span> a * <span class="hljs-number">2</span>;
    };
    <span class="hljs-keyword">var</span> multiplyByTwoSpy = sinon.spy(multiplyByTwo);
    <span class="hljs-keyword">var</span> multiplyByTwoMemoized = memoize(multiplyByTwoSpy);

    expect(multiplyByTwoMemoized(<span class="hljs-number">1</span>)).to.equal(<span class="hljs-number">2</span>);
    expect(multiplyByTwoMemoized(<span class="hljs-number">1</span>)).to.equal(<span class="hljs-number">2</span>);

    expect(multiplyByTwoSpy.calledOnce).to.be.<span class="hljs-keyword">true</span>;
});
</code></pre>
<p>Para este último test he utilizado la librería <a href="http://sinonjs.org/docs/">Sinon.js</a> para poder contar cuentas veces se ha llamado una función.</p>
<h1 id="soluci-n">Solución</h1>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span> <span class="hljs-params">(array, fn)</span> {</span>
    <span class="hljs-keyword">var</span> result = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) {
        result.push(fn(array[i]));
    }
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span> <span class="hljs-params">(fn)</span> {</span>
    <span class="hljs-keyword">var</span> curryArguments = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
    curryArguments.splice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> currentArguments = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">null</span>, curryArguments.concat(currentArguments));
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span> <span class="hljs-params">(fn)</span> {</span>
    <span class="hljs-keyword">var</span> cache = {};
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(param1)</span> {</span>
        <span class="hljs-keyword">if</span> (cache.hasOwnProperty(param1)) {
            <span class="hljs-keyword">return</span> cache[param1];
        }<span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> result = fn(param1);
            cache[param1] = result;
            <span class="hljs-keyword">return</span> result;
        }
    }
}
</code></pre>
<h1 id="referencias">Referencias</h1>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/arguments">https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/arguments</a></li>
<li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742</a></li>
<li><a href="http://sinonjs.org/docs/">http://sinonjs.org/docs/</a></li>
</ul>

  </div>
  <footer><a href="http://twitter.com/axelhzf" about="_blank">Twitter</a><a href="http://github.com/axelhzf" about="_blank">Github</a></footer>
</body>